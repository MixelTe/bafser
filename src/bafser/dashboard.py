import json
import os
import statistics
from datetime import datetime
from typing import Any, Dict, List, Optional, Union

import jinja2
from flask import render_template

import bafser_config

from .logger import get_log_fpath_all

_loc = os.path.abspath(os.path.dirname(__file__))
_templateEnv = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(_loc, "templates")))
_template_dashboard = _templateEnv.get_template("dashboard.html")

# ! Generated by AI as draft, revision required


# Define a TypeAlias for the stats dictionary to keep things clean
StatsDict = Dict[str, Union[float, List[Any], str]]


def calculate_box_stats(data_list: List[float]) -> Optional[StatsDict]:
    if not data_list:
        return None

    data_list.sort()
    n = len(data_list)

    if n == 1:
        val = data_list[0]
        return {"min": val, "q1": val, "median": val, "mean": val, "q3": val, "max": val, "items": []}

    quantiles = statistics.quantiles(data_list, n=4)
    return {
        "min": data_list[0],
        "q1": quantiles[0],
        "median": quantiles[1],
        "mean": statistics.mean(data_list),
        "q3": quantiles[2],
        "max": data_list[-1],
        "items": [],
    }


def render_dashboard_page() -> str:
    logs = get_log_fpath_all(bafser_config.log_dashboard_path)
    # Explicitly type these dictionaries
    traffic: Dict[str, Dict[str, int]] = {}
    raw_durations: Dict[str, List[float]] = {}

    for log in logs:
        if not os.path.exists(log):
            continue
        with open(log, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                try:
                    parts = line.strip().split(";")
                    # Added a check to ensure we have exactly 7 parts to avoid unpacking errors
                    if len(parts) != 7:
                        continue

                    asctime, endpoint, duration, _code, _req_id, _ip, _uid = parts

                    # Traffic aggregation
                    t = datetime.fromisoformat(asctime)
                    hour_key = t.strftime("%Y-%m-%d %H:00")

                    if hour_key not in traffic:
                        traffic[hour_key] = {}
                    traffic[hour_key][endpoint] = traffic[hour_key].get(endpoint, 0) + 1

                    # Store raw for calculation
                    if endpoint not in raw_durations:
                        raw_durations[endpoint] = []
                    raw_durations[endpoint].append(float(duration) / 1000000)
                except (ValueError, IndexError):
                    continue

    # Pre-calculate stats and filter out None values immediately for the type checker
    box_stats: Dict[str, StatsDict] = {route: s for route, durs in raw_durations.items() if (s := calculate_box_stats(durs)) is not None}

    # Base list for ranking - 's' is now guaranteed to be a dict, not None
    all_stats: list[StatsDict] = [{"route": r, "median": s["median"], "max": s["max"], "count": len(raw_durations[r])} for r, s in box_stats.items()]

    # Rank by Median
    slowest_median = sorted(all_stats, key=lambda x: x["median"], reverse=True)[:5]

    # Rank by Max
    slowest_max = sorted(all_stats, key=lambda x: x["max"], reverse=True)[:5]

    hidden_routes = [item["route"] for item in slowest_max]

    # 1. Collect all "Max" values
    all_max_values = sorted([float(s["max"]) for s in box_stats.values()], reverse=True)  # pyright: ignore[reportArgumentType]

    # 2. Find the 6th highest value for the cap
    if len(all_max_values) >= 6:
        latency_cap = all_max_values[5]
    elif all_max_values:
        latency_cap = all_max_values[0]
    else:
        latency_cap = 1000

    latency_cap = max(latency_cap, 1.0)

    capped_box_stats: Dict[str, StatsDict] = {}
    for route, stats in box_stats.items():
        capped = stats.copy()
        for key in ["min", "q1", "median", "q3", "max"]:
            # Type narrowing: ensure the value is a float before comparison
            val = capped[key]
            if isinstance(val, (int, float)) and val > latency_cap:
                capped[key] = latency_cap
        capped_box_stats[route] = capped

    return render_template(
        _template_dashboard,
        endpoints=json.dumps(
            {
                "traffic": traffic,
                "box_stats": capped_box_stats,
                "slowest_median": slowest_median,
                "slowest_max": slowest_max,
                "hidden_routes": hidden_routes,
            },
        ),
    )
